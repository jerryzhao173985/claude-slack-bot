name: Claude Code Processor (Best Experience)

on:
  workflow_dispatch:
    inputs:
      question:
        description: "User question from Slack"
        required: true
        type: string
      slack_channel:
        description: "Slack channel ID"
        required: true
        type: string
      slack_ts:
        description: "Slack message timestamp"
        required: true
        type: string
      slack_thread_ts:
        description: "Slack thread timestamp"
        required: false
        type: string
      system_prompt:
        description: "Additional context (e.g., thread history)"
        required: false
        type: string
      model:
        description: "Claude model to use"
        required: false
        type: string
        default: "claude-sonnet-4-20250514"
      max_turns:
        description: "Maximum conversation turns (dynamically calculated)"
        required: false
        type: string
        default: "15"
      timeout_minutes:
        description: "Workflow timeout in minutes (dynamically calculated)"
        required: false
        type: string
        default: "30"
      session_id:
        description: "Session ID to resume a previous conversation"
        required: false
        type: string
      parent_run_id:
        description: "Parent workflow run ID for checkpoint chaining"
        required: false
        type: string

jobs:
  process-request:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_minutes || '30') }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup environment
        run: |
          mkdir -p outputs
          mkdir -p outputs/checkpoints
          mkdir -p ~/.local/bin
          
          # Create a file to indicate Claude is running
          touch .claude_running
          
          # Create session info file
          SESSION_ID="${{ github.event.inputs.session_id }}"
          if [ -z "$SESSION_ID" ] || [ "$SESSION_ID" = "null" ] || [ "$SESSION_ID" = "new-session" ]; then
            # Generate a new session ID based on run ID
            # Prefix with 'r' to distinguish from session IDs
            SESSION_ID="r${{ github.run_id }}"
            echo "Starting new session with ID: $SESSION_ID"
          else
            echo "Resuming session: $SESSION_ID"
            # Validate session ID format (should start with 's' or 'r' followed by alphanumeric)
            if ! echo "$SESSION_ID" | grep -qE '^[sr][a-zA-Z0-9]+$'; then
              echo "Warning: Session ID format may be invalid: $SESSION_ID"
            fi
          fi
          echo "$SESSION_ID" > outputs/session_id.txt
          echo "SESSION_ID=$SESSION_ID" >> $GITHUB_ENV
          
          # Log session info for debugging
          echo "SESSION_INFO: ID=$SESSION_ID, Type=${SESSION_ID:0:1}, ThreadTS=${{ github.event.inputs.slack_thread_ts }}"
      
      - name: Install GitHub MCP Server
        run: |
          echo "Downloading github-mcp-server binary..."
          curl -L https://github.com/github/github-mcp-server/releases/download/v0.5.0/github-mcp-server_Linux_x86_64.tar.gz | tar xz -C ~/.local/bin
          chmod +x ~/.local/bin/github-mcp-server
          echo "$HOME/.local/bin" >> $GITHUB_PATH
      
      - name: Checkpoint Discovery and Download
        if: github.event.inputs.session_id != '' && github.event.inputs.session_id != 'null' && github.event.inputs.session_id != 'new-session'
        continue-on-error: true
        run: |
          echo "=== Checkpoint Discovery ==="
          echo "Current Thread: ${{ github.event.inputs.slack_thread_ts }}"
          echo "Session ID: ${{ env.SESSION_ID }}"
          echo "Repository: ${{ github.repository }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "Note: Cross-run artifact download requires GitHub API"
          echo "================================"
          
      - name: GitHub API Checkpoint Discovery
        if: github.event.inputs.session_id != '' && github.event.inputs.session_id != 'null' && github.event.inputs.session_id != 'new-session'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "=== GitHub API Checkpoint Search ==="
          echo "Searching for checkpoints across all workflow runs..."
          echo "Session: ${{ env.SESSION_ID }}"
          echo "Thread: ${{ github.event.inputs.slack_thread_ts }}"
          echo ""
          
          # Create checkpoint directory
          mkdir -p outputs/checkpoints
          
          # List all available checkpoint artifacts
          echo "Fetching all checkpoint artifacts..."
          gh api repos/${{ github.repository }}/actions/artifacts --paginate | \
            jq -r '.artifacts[] | select(.name | startswith("checkpoint-")) | {name: .name, created_at: .created_at, expires_at: .expires_at, id: .id, size_in_bytes: .size_in_bytes}' | \
            jq -s 'sort_by(.created_at) | reverse' > available_checkpoints.json
          
          if [ -s available_checkpoints.json ]; then
            echo "Available checkpoints:"
            cat available_checkpoints.json | jq -r '.[] | "\(.name) (created: \(.created_at), expires: \(.expires_at))"'
            
            echo ""
            echo "Search Strategies:"
            echo "1. Exact session ID match"
            echo "2. Thread-based search (most reliable)"
            echo "3. Recent checkpoints fallback"
            echo ""
            
            # Strategy 1: Try exact session ID match
            SESSION_PATTERN="${{ env.SESSION_ID }}"
            MATCHING_CHECKPOINT=$(cat available_checkpoints.json | jq -r ".[] | select(.name | contains(\"$SESSION_PATTERN\")) | .name" | head -1)
            
            if [ -n "$MATCHING_CHECKPOINT" ]; then
              echo "✓ Strategy 1: Found exact match: $MATCHING_CHECKPOINT"
            else
              echo "✗ Strategy 1: No exact match for session $SESSION_PATTERN"
              
              # Strategy 2: Search by thread (download and check thread_ts)
              if [ -n "${{ github.event.inputs.slack_thread_ts }}" ]; then
                echo ""
                echo "Strategy 2: Searching by thread_ts..."
                THREAD_TS="${{ github.event.inputs.slack_thread_ts }}"
                
                # Check recent checkpoints for thread match
                CHECKPOINT_COUNT=$(cat available_checkpoints.json | jq -r '. | length')
                echo "Checking $CHECKPOINT_COUNT checkpoint(s) for thread match..."
                
                # Download and check up to 5 most recent checkpoints
                CHECKED=0
                for row in $(cat available_checkpoints.json | jq -r '.[] | @base64' | head -5); do
                  _jq() {
                    echo ${row} | base64 --decode | jq -r ${1}
                  }
                  
                  CHECKPOINT_NAME=$(_jq '.name')
                  ARTIFACT_ID=$(_jq '.id')
                  CHECKED=$((CHECKED + 1))
                  
                  echo "  Checking $CHECKED: $CHECKPOINT_NAME..."
                  
                  # Download to temp location
                  TEMP_DIR=$(mktemp -d)
                  if gh api repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip \
                    -H "Accept: application/vnd.github+json" > $TEMP_DIR/checkpoint.zip 2>/dev/null; then
                    
                    if unzip -q $TEMP_DIR/checkpoint.zip -d $TEMP_DIR/ 2>/dev/null; then
                      # Check if progress.json exists and has matching thread_ts
                      if [ -f "$TEMP_DIR/progress.json" ]; then
                        CHECKPOINT_THREAD=$(jq -r '.thread_ts // ""' $TEMP_DIR/progress.json 2>/dev/null || echo "")
                        CHECKPOINT_VERSION=$(jq -r '.version // "1.0"' $TEMP_DIR/progress.json 2>/dev/null || echo "1.0")
                        
                        if [ "$CHECKPOINT_THREAD" = "$THREAD_TS" ]; then
                          echo "    ✓ Thread match found! (version $CHECKPOINT_VERSION)"
                          MATCHING_CHECKPOINT="$CHECKPOINT_NAME"
                          rm -rf $TEMP_DIR
                          break
                        else
                          echo "    ✗ Different thread: $CHECKPOINT_THREAD"
                        fi
                      else
                        echo "    ✗ No progress.json found"
                      fi
                    fi
                  fi
                  rm -rf $TEMP_DIR
                done
                
                if [ -z "$MATCHING_CHECKPOINT" ]; then
                  echo "✗ Strategy 2: No checkpoint found for thread $THREAD_TS"
                else
                  echo "✓ Strategy 2: Found checkpoint for thread: $MATCHING_CHECKPOINT"
                fi
              fi
              
              # Strategy 3: Fallback to most recent checkpoint
              if [ -z "$MATCHING_CHECKPOINT" ]; then
                echo ""
                echo "Strategy 3: Using most recent checkpoint as fallback..."
                MATCHING_CHECKPOINT=$(cat available_checkpoints.json | jq -r '.[0].name' 2>/dev/null || echo "")
                if [ -n "$MATCHING_CHECKPOINT" ]; then
                  echo "✓ Strategy 3: Found recent checkpoint: $MATCHING_CHECKPOINT"
                fi
              fi
            fi
            
            # Download the checkpoint if found
            if [ -n "$MATCHING_CHECKPOINT" ]; then
              echo "Attempting to download checkpoint: $MATCHING_CHECKPOINT"
              ARTIFACT_ID=$(cat available_checkpoints.json | jq -r ".[] | select(.name == \"$MATCHING_CHECKPOINT\") | .id" | head -1)
              
              if [ -n "$ARTIFACT_ID" ]; then
                echo "Downloading artifact ID: $ARTIFACT_ID"
                mkdir -p outputs/checkpoints
                gh api repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip \
                  -H "Accept: application/vnd.github+json" > checkpoint.zip
                
                # Extract and verify
                if unzip -o checkpoint.zip -d outputs/checkpoints/; then
                  echo "Checkpoint extracted successfully"
                  rm -f checkpoint.zip
                  
                  # Check if checkpoint contains thread info
                  if [ -f "outputs/checkpoints/progress.json" ]; then
                    echo ""
                    echo "=== Checkpoint Loaded Successfully ==="
                    
                    # Display checkpoint metadata
                    CHECKPOINT_VERSION=$(jq -r '.version // "1.0"' outputs/checkpoints/progress.json)
                    CHECKPOINT_SESSION=$(jq -r '.session_id // "unknown"' outputs/checkpoints/progress.json)
                    CHECKPOINT_THREAD=$(jq -r '.thread_ts // ""' outputs/checkpoints/progress.json 2>/dev/null || echo "")
                    CHECKPOINT_PHASE=$(jq -r '.phase // "unknown"' outputs/checkpoints/progress.json)
                    CHECKPOINT_PROGRESS=$(jq -r '.progress_percentage // 0' outputs/checkpoints/progress.json)
                    CHECKPOINT_TIMESTAMP=$(jq -r '.timestamp // "unknown"' outputs/checkpoints/progress.json)
                    
                    echo "Version: $CHECKPOINT_VERSION"
                    echo "Session: $CHECKPOINT_SESSION"
                    echo "Thread: ${CHECKPOINT_THREAD:-not recorded (v1.0)}"
                    echo "Phase: $CHECKPOINT_PHASE"
                    echo "Progress: $CHECKPOINT_PROGRESS%"
                    echo "Saved at: $CHECKPOINT_TIMESTAMP"
                    
                    # Display context summary
                    echo ""
                    echo "Context Summary:"
                    jq -r '.context.original_request // "No request recorded"' outputs/checkpoints/progress.json
                    
                    # Verify thread match if possible
                    CURRENT_THREAD="${{ github.event.inputs.slack_thread_ts }}"
                    
                    if [ -n "$CHECKPOINT_THREAD" ] && [ -n "$CURRENT_THREAD" ]; then
                      if [ "$CHECKPOINT_THREAD" = "$CURRENT_THREAD" ]; then
                        echo ""
                        echo "✓ Thread verification: Checkpoint is from the same conversation"
                      else
                        echo ""
                        echo "⚠ Thread mismatch: Checkpoint from different thread"
                        echo "  Checkpoint thread: $CHECKPOINT_THREAD"
                        echo "  Current thread: $CURRENT_THREAD"
                      fi
                    elif [ -z "$CHECKPOINT_THREAD" ] && [ "$CHECKPOINT_VERSION" = "1.0" ]; then
                      echo ""
                      echo "ℹ Note: Version 1.0 checkpoint - thread verification not available"
                    fi
                    
                    # Show pending work if any
                    PENDING_COUNT=$(jq -r '.pending.steps | length' outputs/checkpoints/progress.json 2>/dev/null || echo "0")
                    if [ "$PENDING_COUNT" -gt "0" ]; then
                      echo ""
                      echo "Pending Steps ($PENDING_COUNT):"
                      jq -r '.pending.steps[]' outputs/checkpoints/progress.json 2>/dev/null | head -5 | sed 's/^/  - /'
                    fi
                    
                    echo "====================================="
                  fi
                else
                  echo "Failed to extract checkpoint"
                  rm -f checkpoint.zip
                fi
              fi
            else
              echo "No suitable checkpoint found"
            fi
          else
            echo "No checkpoints available in repository"
          fi
          
      
      - name: Start Progress Monitor
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: ${{ github.event.inputs.slack_channel }}
          SLACK_TS: ${{ github.event.inputs.slack_ts }}
        run: |
          # Background process to update Slack with progress
          # Use setsid to create a new process group for easier cleanup
          # Export variables for the subshell
          export SLACK_BOT_TOKEN SLACK_CHANNEL SLACK_TS
          
          setsid bash -c '
            while [ -f ".claude_running" ]; do
              if [ -f "outputs/checkpoints/progress.json" ]; then
                PROGRESS=$(jq -r ".progress_percentage // 0" outputs/checkpoints/progress.json 2>/dev/null || echo 0)
                PHASE=$(jq -r ".phase // \"initializing\"" outputs/checkpoints/progress.json 2>/dev/null || echo "initializing")
                
                # Create progress bar
                FILLED=$((PROGRESS / 5))
                EMPTY=$((20 - FILLED))
                BAR=""
                for i in $(seq 1 $FILLED); do BAR="${BAR}█"; done
                for i in $(seq 1 $EMPTY); do BAR="${BAR}░"; done
                
                # Update Slack message with progress
                curl -s -X POST https://slack.com/api/chat.update \
                  -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "{
                    \"channel\": \"${SLACK_CHANNEL}\",
                    \"ts\": \"${SLACK_TS}\",
                    \"text\": \"🤔 Working on your request... [${PROGRESS}%] - ${PHASE}\\n${BAR}\"
                  }" > /dev/null 2>&1
              fi
              sleep 30
            done
          ' > /tmp/progress_monitor.log 2>&1 &
          MONITOR_PID=$!
          echo "Progress monitor started with PID $MONITOR_PID"
          echo $MONITOR_PID > .monitor_pid
      
      - name: Configure Claude settings
        id: claude-config
        run: |
          # Model-specific settings
          if [[ "${{ github.event.inputs.model }}" == "claude-3-5-sonnet-20241022" ]]; then
            THINKING="false"
          else
            THINKING="true"
          fi
          
          # Output environment variables
          cat > claude_env.txt << EOF
          ANTHROPIC_PROMPT_CACHING=1
          CLAUDE_CODE_AUTORUN_TOOLS=true
          CLAUDE_CODE_THINKING=$THINKING
          CLAUDE_CODE_DANGEROUSLY_SKIP_PERMISSIONS=true
          EOF
          
          # Set output for GitHub Actions
          echo "claude_env<<EOF" >> $GITHUB_OUTPUT
          cat claude_env.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Process with Claude
        id: claude-process
        uses: anthropics/claude-code-base-action@beta
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          prompt: |
            You are Claude, a helpful Slack bot assistant.
            
            **User Question:** ${{ github.event.inputs.question }}
            **Channel:** ${{ github.event.inputs.slack_channel }}
            **Thread:** ${{ github.event.inputs.slack_thread_ts || github.event.inputs.slack_ts }}
            **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
            
            ## Instructions
            
            ### 0. Session Management
            - Session ID: Check outputs/session_id.txt for the actual session ID
            - If this is a resumed session, check for checkpoint files in `outputs/checkpoints/`
            - Continue from the last checkpoint if available
            - IMPORTANT: Always use the session ID from outputs/session_id.txt in your checkpoints
            - DEBUG: The input session_id is: ${{ github.event.inputs.session_id }}
            - DEBUG: The checkpoint artifact name should be: checkpoint-${{ env.SESSION_ID }}
            
            **Checkpoint Loading Behavior**:
            - Strategy 1: Exact session ID match (fastest)
            - Strategy 2: Thread-based search - checks recent checkpoints for matching thread_ts (most reliable)
            - Strategy 3: Most recent checkpoint fallback (last resort)
            - Handles version differences (1.0, 1.1, 1.2) gracefully
            - Shows full checkpoint metadata and pending work
            - IMPORTANT: Always save checkpoints with version 1.2 format including thread_ts
            
            ### CRITICAL: Tool Call Best Practices to Prevent Errors
            To avoid "tool_use ids were found without tool_result blocks" errors:
            
            1. **Track Your Tool Calls**:
               - Maintain a mental list of files you've already read
               - NEVER make duplicate calls to fetch the same file
               - If you need file content again, refer to your previous read
            
            2. **Batch Tool Calls Efficiently**:
               - When reading multiple files, make ALL read calls in a single response
               - Example: If you need README.md and package.json, call both tools at once
               - This ensures proper tool_use/tool_result pairing
            
            3. **Before Any Tool Call**:
               - Ask yourself: "Have I already fetched this content?"
               - If YES: Use the content from memory
               - If NO: Make the tool call ONCE
               - If UNSURE: Check your conversation history first
            
            4. **Tool Call Sequence Rules**:
               - Each tool_use MUST have a corresponding tool_result
               - Wait for results before making new tool calls
               - Never make the same tool call twice in one session
            
            5. **File Reading Guidelines**:
               - Read each file ONLY ONCE per session
               - Cache file contents in your context
               - Announce which files you're about to read: "I'll read files: X, Y, Z"
               - Then read them all in one tool response
            
            ### 1. Smart Checkpointing Rules
            Use checkpoints as a structured work journal that records essential data and key decisions through process. 
            Keep intent clear to ensure continuity and transparency, consistently capture defined data points in session. 
            Apply judgment thoughtfully to decide when and how each checkpoint should be created.
            CRITICAL: You have ${{ github.event.inputs.timeout_minutes || '30' }} minutes total execution time.
            You can save checkpoint at these critical times:
            - EVERY 5 MINUTES (set a mental timer)
            - EVERY 10-15 TURNS (not every 5 - too frequent)
            - After completing major phases (analysis, implementation, testing, finalization)
            - Before risky operations to enable recovery (file updates, PR creation)
            - When completing a task or major subtask
            - ALWAYS save a final checkpoint with 100% progress after completing ALL tasks and before exiting

            Following is an example format but you can extend on more additional fields with specific details as relevant, necessary and helpful:
            
            Checkpoint format (save to `outputs/checkpoints/progress.json`):
            ```json
            {
              "version": "1.2",
              "workflow_run_id": "${{ github.run_id }}",
              "workflow_run_number": "${{ github.run_number }}",
              "parent_run_id": "${{ github.event.inputs.parent_run_id }}",
              "timestamp": "2025-01-01T00:00:00Z",
              "session_id": "[READ FROM outputs/session_id.txt]",
              "thread_ts": "${{ github.event.inputs.slack_thread_ts }}",
              "channel": "${{ github.event.inputs.slack_channel }}",
              "github_repo": "${{ github.repository }}",
              "model_used": "${{ github.event.inputs.model }}",
              "phase": "analysis|implementation|testing|finalization",
              "progress_percentage": 25,
              "turns_used": 10,
              "max_turns": ${{ github.event.inputs.max_turns || '15' }},
              "checkpoint_chain": ["checkpoint-r15749536247", "checkpoint-s000082b749f"],
              "completed": {
                "files_created": ["file1.ts", "file2.ts"],
                "files_modified": ["file3.ts"],
                "files_deleted": [],
                "analysis_complete": true,
                "implementation_complete": false,
                "tests_added": false,
                "tests_passing": false,
                "pr_branch": "feature/xyz-12345",
                "pr_created": false,
                "pr_number": null,
                "pr_url": null,
                "documentation_updated": false,
                "commits_made": ["Initial commit message"],
                "github_operations": ["created_branch", "pushed_files"],
                "mcp_tools_used": ["github", "slack"],
                "errors_encountered": [],
                "warnings": []
              },
              "pending": {
                "steps": ["Create PR", "Add tests"],
                "estimated_turns": 10,
                "blockers": [],
                "next_action": "Create pull request with comprehensive description"
              },
              "context": {
                "original_request": "${{ github.event.inputs.question }}",
                "key_findings": "Detailed analysis results...",
                "decisions_made": "Technical decisions and rationale...",
                "implementation_details": "What was changed and why...",
                "partial_work": "Description of any incomplete work",
                "summary": "High-level summary of progress and accomplishments"
              },
              [additional fields],
              "plan":{
                {[plan executed along the process planning stages/ thinking process]},  
              },
              "code":{
                {[necessary file/code change snippets and analysis]}
              },
              [other additional fields]
            }
            ```
            
            CRITICAL: Before saving checkpoint:
            1. Read the session ID from outputs/session_id.txt
            2. Include that exact session ID in the checkpoint JSON
            3. This ensures checkpoint can be found when resuming
            
            ### Checkpoint Information Gathering:
            Throughout your work, actively track and update:
            - **Files**: Keep exact lists of created/modified/deleted files
            - **GitHub Operations**: Log every branch creation, push, PR operation
            - **Progress Markers**: Update booleans (analysis_complete, tests_passing, etc.)
            - **PR Details**: Capture PR number and URL immediately after creation
            - **Commits**: Track all commit messages made
            - **Tools Used**: Note which MCP tools were utilized
            - **Errors/Warnings**: Document any issues encountered
            - **Context**: Continuously update findings, decisions, implementation details
            - **Summary**: Maintain a clear high-level summary of accomplishments
            
            IMPORTANT: When a PR is created, immediately update checkpoint with:
            - pr_created: true
            - pr_number: (actual number)
            - pr_url: (full URL)
            - phase: "completed" (if all done)
            - progress_percentage: 100 (if all done)
            
            Progress Percentage Guidelines:
            - 0-25%: Analysis and understanding phase
            - 26-75%: Implementation/coding phase
            - 76-90%: Testing and validation phase
            - 91-99%: PR creation, documentation phase
            - 100%: Only when PR is created and all tasks complete
            - Subject to dynamic adjustment per question and planned stages for specific session
            - **IMPORTANT: Always save a 100% checkpoint after completing all tasks, including PR creation**
            
            IMPORTANT: If approaching timeout, IMMEDIATELY:
            1. Save current work state to checkpoint
            2. Write partial response to outputs/slack_response.txt
            3. Include what was completed and what remains
            
            ### 2. Process the Request
            - If resuming session, load checkpoint from outputs/checkpoints/progress.json
            - Analyze the user's question thoroughly
            - CRITICAL: If the question is short (e.g., "do it", "solve this", "continue"), check the thread context to understand what task to complete
            - Look for unfinished tasks or requests in the thread history and complete them
            - Use any necessary MCP tools to gather information
            - For GitHub repositories, Claude will automatically understand and work with any GitHub URLs you provide
            - When creating branches, use unique names with timestamps: feature/[description]-[timestamp]
            - If branch creation fails due to "already exists", use a different name or timestamp
            - Save checkpoint BEFORE attempting complex GitHub operations
            - **CRITICAL: Save checkpoint IMMEDIATELY AFTER completing major operations (PR creation, documentation, etc.)**
            
            ### CRITICAL: GitHub File Update Guidelines
            To prevent 10-minute timeouts when updating GitHub files:
            
            1. **Decision Rule**: 
               - NEW file (doesn't exist yet) → `mcp__github__create_or_update_file` ✅
               - EXISTING file (already in repo) → `mcp__github__push_files` ✅
               - Multiple files → Always `mcp__github__push_files` ✅
               - When unsure → Use `mcp__github__push_files` (works for both) ✅
            
            2. **Why This Matters**:
               - GitHub API REQUIRES current file SHA for updates
               - `create_or_update_file` can't get SHA = hangs for 10 minutes
               - `push_files` handles SHA automatically using Trees API
            
            3. **Common Tasks**:
               - "Fix typo" → Use `push_files` (file exists)
               - "Update config" → Use `push_files` (file exists)
               - "Add new feature" → Check first, if new use `create_or_update_file`
               - "Batch updates" → Always use `push_files`
            
            4. **Before Any File Operation**:
               - Think: "Does this file already exist in the repo?"
               - If YES or UNSURE → Use `push_files`
               - Only use `create_or_update_file` when 100% certain file is NEW
            
            ### 3. Save to Notion
            - If Notion MCP is available, try to save Q&A to Notion
            - Search for "Claude Code" page using `mcp__notionApi__API-post-search`
            - If found, create a sub-page using `mcp__notionApi__API-post-page` with ALL content in the `children` array:
              ```json
              {
                "parent": { "page_id": "<CLAUDE_CODE_PAGE_ID>" },
                "properties": {
                  "title": { "title": [{ "text": { "content": "<Clean title, max 50 chars>" } }] }
                },
                "children": [
                  { "heading_1": { "rich_text": [{ "text": { "content": "<Title>" } }] } },
                  { "heading_2": { "rich_text": [{ "text": { "content": "Question" } }] } },
                  { "paragraph": { "rich_text": [{ "text": { "content": "${{ github.event.inputs.question }}" } }] } },
                  { "heading_2": { "rich_text": [{ "text": { "content": "Answer" } }] } },
                  { "paragraph": { "rich_text": [{ "text": { "content": "<Your complete response>" } }] } },
                  { "heading_2": { "rich_text": [{ "text": { "content": "Metadata" } }] } },
                  { "bulleted_list_item": { "rich_text": [{ "text": { "content": "Timestamp: $(date -u +\"%Y-%m-%d %H:%M:%S UTC\")" } }] } },
                  { "bulleted_list_item": { "rich_text": [{ "text": { "content": "Channel: ${{ github.event.inputs.slack_channel }}" } }] } },
                  { "bulleted_list_item": { "rich_text": [{ "text": { "content": "Model: ${{ github.event.inputs.model }}" } }] } }
                ]
              }
              ```
            - IMPORTANT: Include ALL content blocks in the `children` array when creating the page
            
            ### 4. Resource Management
            Monitor your resource usage carefully:
            - Total turns available: ${{ github.event.inputs.max_turns || '15' }}
            - At 70% of turns: Start consolidating work and create comprehensive checkpoint
            - At 80%: Focus only on critical items, prepare for continuation
            - At 90%: Save all work immediately with detailed next steps
            - At 95%: Emergency save with exact continuation instructions
                ```
            - If you're running low on turns (less than 5 remaining), immediately save a checkpoint
            - This allows the task to be resumed if it times out or runs out of turns
            
            ### 4. CRITICAL: Check Thread Context First
            - If the message is short like "solve this", "do it", "continue", check the system prompt for thread context
            - The thread history shows what task was previously discussed
            - Complete the task mentioned in the thread without asking for clarification
            - Example: If thread mentions "create a PR", then "solve this" means create that PR
            
            ### 5. Save Response to File (REQUIRED)
            - IMPORTANT: You MUST save a response before running out of turns
            - Monitor your progress - if approaching turn limit, wrap up and save
            - Save your response to: `outputs/slack_response.txt`
            - Use the Write tool to save the file
            - Format your response appropriately for Slack (use markdown where helpful)
            - Save the clean response text that should be shown to the user
            - Metadata will be automatically appended to your response by the workflow
            - If you couldn't complete everything:
              - Save a final checkpoint with exact next steps
              - Include in response: "✅ Made significant progress! I've completed [X]. To finish [Y], just say 'continue'."
              - List what was accomplished and what remains
            - **CRITICAL: After saving your response, if all tasks are complete, save a final checkpoint with progress_percentage: 100**
            
            ### 6. Exit Protocol (CRITICAL)
            Before ending your session, you MUST follow this protocol:
            1. Verify all requested tasks are complete
            2. Save your final response to `outputs/slack_response.txt`
            3. **ALWAYS save a final checkpoint with:**
               - progress_percentage: 100 (if all tasks complete) or accurate percentage if partial
               - phase: "completed" (if 100%) or current phase
               - pending.steps: [] (empty array if 100%) or list remaining tasks
               - completed: Include ALL work done (files, PRs, documentation, etc.)
               - context: Include comprehensive summary of what was accomplished
            4. Only after saving the final checkpoint can you conclude your work
            
            **Example Final Checkpoint (100% complete):**
            ```json
            {
              "progress_percentage": 100,
              "phase": "completed",
              "completed": {
                "files_modified": ["src/Robot.cpp", "include/Robot.h"],
                "branch_created": "fix/hexapod-robot-construction-20250619",
                "pr_created": true,
                "pr_number": 123,
                "pr_url": "https://github.com/owner/repo/pull/123",
                "documentation_updated": true,
                "all_tests_passing": true,
                "commits_made": ["Fixed hexapod anatomy", "Synced physics with visual model"],
                "github_operations": ["created_branch", "pushed_files", "created_pr"]
              },
              "pending": {
                "steps": [],
                "estimated_turns": 0
              },
              "context": {
                "original_request": "Fix hexapod robot simulation...",
                "summary": "Successfully completed hexapod robot fix: rewrote physics model, created PR #123, updated documentation",
                "implementation_details": "Complete rewrite of Robot.cpp to match Visualizer's hexapod model"
              }
            }
            ```
            
            **Typical Completion Flow:**
            1. Complete all implementation work → Save checkpoint (75%)
            2. Run tests/validation → Save checkpoint (85%)
            3. Create PR using GitHub MCP tool → Save checkpoint (95%)
            4. Update documentation → Save checkpoint (98%)
            5. Verify all tasks complete
            6. Save response to `outputs/slack_response.txt`
            7. **Save final checkpoint (100%) with all PR details**
            8. Exit

            ### Completion Recognition
            When you recognize that all requested tasks are complete:
            1. Save your final response to `outputs/slack_response.txt`
            2. Save a checkpoint that captures your complete accomplishments
            3. Ensure progress_percentage reflects true completion (100% if all done)
            
            ### Important Notes
            - The Slack MCP server cannot update messages, only post new ones
            - By saving to the file, the workflow can update the placeholder message
            - This provides a cleaner experience than posting a new reply
            - Make sure to save the response BEFORE attempting complex operations
            - If running low on turns, prioritize saving a partial response over completing everything
            - If task wasn't completed:
              - The system will automatically suggest continuation
              - User can simply say "continue" to resume
              - Session ID is managed automatically based on thread
          
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          anthropic_model: ${{ github.event.inputs.model }}
          append_system_prompt: ${{ github.event.inputs.system_prompt }}
          allowed_tools: |
            Write,
            Read,
            Bash,
            WebSearch,
            mcp__slack__slack_get_thread_replies,
            mcp__slack__slack_get_users,
            mcp__slack__slack_get_user_profile,
            mcp__slack__slack_get_channel_history,
            mcp__notionApi__API-post-search,
            mcp__notionApi__API-post-page,
            mcp__github__get_me,
            mcp__github__get_issue,
            mcp__github__get_issue_comments,
            mcp__github__list_issues,
            mcp__github__search_issues,
            mcp__github__create_issue,
            mcp__github__add_issue_comment,
            mcp__github__update_issue,
            mcp__github__get_pull_request,
            mcp__github__list_pull_requests,
            mcp__github__get_pull_request_files,
            mcp__github__get_pull_request_comments,
            mcp__github__get_pull_request_diff,
            mcp__github__get_pull_request_reviews,
            mcp__github__get_pull_request_status,
            mcp__github__create_pull_request,
            mcp__github__merge_pull_request,
            mcp__github__update_pull_request,
            mcp__github__update_pull_request_branch,
            mcp__github__create_pending_pull_request_review,
            mcp__github__add_pull_request_review_comment_to_pending_review,
            mcp__github__submit_pending_pull_request_review,
            mcp__github__delete_pending_pull_request_review,
            mcp__github__create_and_submit_pull_request_review,
            mcp__github__request_copilot_review,
            mcp__github__assign_copilot_to_issue,
            mcp__github__search_repositories,
            mcp__github__create_repository,
            mcp__github__fork_repository,
            mcp__github__get_file_contents,
            mcp__github__create_or_update_file,
            mcp__github__delete_file,
            mcp__github__push_files,
            mcp__github__create_branch,
            mcp__github__list_branches,
            mcp__github__list_commits,
            mcp__github__get_commit,
            mcp__github__search_code,
            mcp__github__list_tags,
            mcp__github__get_tag,
            mcp__github__search_users,
            mcp__github__list_notifications,
            mcp__github__get_notification_details,
            mcp__github__mark_all_notifications_read,
            mcp__github__dismiss_notification,
            mcp__github__manage_notification_subscription,
            mcp__github__manage_repository_notification_subscription,
            mcp__github__list_code_scanning_alerts,
            mcp__github__get_code_scanning_alert,
            mcp__github__list_secret_scanning_alerts,
            mcp__github__get_secret_scanning_alert
          mcp_config: |
            {
              "mcpServers": {
                "slack": {
                  "command": "npx",
                  "args": ["-y", "@modelcontextprotocol/server-slack"],
                  "env": { 
                    "SLACK_BOT_TOKEN": "${{ secrets.SLACK_BOT_TOKEN }}",
                    "SLACK_TEAM_ID": "${{ secrets.SLACK_TEAM_ID }}" 
                  }
                },
                "notionApi": {
                  "command": "npx",
                  "args": ["-y", "@notionhq/notion-mcp-server"],
                  "env": { 
                    "OPENAPI_MCP_HEADERS": "{\"Authorization\":\"Bearer ${{ secrets.NOTION_KEY }}\",\"Notion-Version\":\"2022-06-28\"}"
                  }
                },
                "github": {
                  "command": "github-mcp-server",
                  "args": ["stdio", "--toolsets", "all"],
                  "env": { 
                    "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GH_TOKEN }}" 
                  }
                }
              }
            }
          max_turns: ${{ github.event.inputs.max_turns || '15' }}
          timeout_minutes: ${{ github.event.inputs.timeout_minutes || '30' }}
          claude_env: ${{ steps.claude-config.outputs.claude_env }}
      
      - name: Extract and Append Metadata
        if: steps.claude-process.outcome == 'success'
        continue-on-error: true
        run: |
          echo "Extracting metadata from Claude execution..."
          
          # Check if execution file exists
          EXECUTION_FILE="${{ steps.claude-process.outputs.execution_file }}"
          if [ -z "$EXECUTION_FILE" ] || [ ! -f "$EXECUTION_FILE" ]; then
            echo "No execution file found, checking default location..."
            # Try default location from logs
            EXECUTION_FILE="/home/runner/work/_temp/claude-execution-output.json"
          fi
          
          if [ -f "$EXECUTION_FILE" ]; then
            echo "Found execution file at: $EXECUTION_FILE"
            
            # Extract metadata using jq (handle both regular and error_during_execution results)
            # The execution file is in JSONL format (JSON Lines - one JSON per line)
            # Process each line separately and only select objects with type="result"
            METADATA=$(cat "$EXECUTION_FILE" | jq -r 'select(type == "object" and .type == "result") | {
              cost: .total_cost_usd,
              duration_ms: .duration_ms,
              duration_api_ms: .duration_api_ms,
              num_turns: .num_turns,
              session_id: .session_id,
              input_tokens: ((.usage.input_tokens // 0) + (.usage.cache_read_input_tokens // 0)),
              output_tokens: (.usage.output_tokens // 0),
              cache_creation_tokens: (.usage.cache_creation_input_tokens // 0),
              is_error: (.is_error // false),
              subtype: (.subtype // "success")
            }' 2>/dev/null | tail -1)
            
            if [ -n "$METADATA" ] && [ "$METADATA" != "null" ]; then
              # Parse individual fields
              COST=$(echo "$METADATA" | jq -r '.cost // 0' | xargs printf "%.2f")
              DURATION_MS=$(echo "$METADATA" | jq -r '.duration_ms // 0')
              API_DURATION_MS=$(echo "$METADATA" | jq -r '.duration_api_ms // 0')
              NUM_TURNS=$(echo "$METADATA" | jq -r '.num_turns // 0')
              SESSION_ID=$(echo "$METADATA" | jq -r '.session_id // "unknown"')
              INPUT_TOKENS=$(echo "$METADATA" | jq -r '.input_tokens // 0')
              OUTPUT_TOKENS=$(echo "$METADATA" | jq -r '.output_tokens // 0')
              CACHE_TOKENS=$(echo "$METADATA" | jq -r '.cache_creation_tokens // 0')
              
              # Convert durations to human-readable format
              DURATION_SEC=$((DURATION_MS / 1000))
              DURATION_MIN=$((DURATION_SEC / 60))
              DURATION_REMAINING_SEC=$((DURATION_SEC % 60))
              
              API_DURATION_SEC=$((API_DURATION_MS / 1000))
              API_DURATION_MIN=$((API_DURATION_SEC / 60))
              API_DURATION_REMAINING_SEC=$((API_DURATION_SEC % 60))
              
              # Format token numbers with commas
              format_number() {
                echo "$1" | sed ':a;s/\B[0-9]\{3\}\>/,&/;ta'
              }
              
              INPUT_TOKENS_FORMATTED=$(format_number "$INPUT_TOKENS")
              OUTPUT_TOKENS_FORMATTED=$(format_number "$OUTPUT_TOKENS")
              TOTAL_TOKENS=$((${INPUT_TOKENS:-0} + ${OUTPUT_TOKENS:-0}))
              TOTAL_TOKENS_FORMATTED=$(format_number "$TOTAL_TOKENS")
              
              # Append metadata to response file
              if [ -f "outputs/slack_response.txt" ]; then
                echo "" >> outputs/slack_response.txt
                echo "---" >> outputs/slack_response.txt
                echo "📊 **Execution Details**" >> outputs/slack_response.txt
                echo "• 💰 Cost: \$$COST" >> outputs/slack_response.txt
                echo "• ⏱️ Duration: ${DURATION_MIN}m ${DURATION_REMAINING_SEC}s (API: ${API_DURATION_MIN}m ${API_DURATION_REMAINING_SEC}s)" >> outputs/slack_response.txt
                echo "• 🔄 Turns: $NUM_TURNS/${{ github.event.inputs.max_turns || '15' }}" >> outputs/slack_response.txt
                echo "• 🎯 Tokens: ${INPUT_TOKENS_FORMATTED} in / ${OUTPUT_TOKENS_FORMATTED} out (${TOTAL_TOKENS_FORMATTED} total)" >> outputs/slack_response.txt
                if [ -n "$CACHE_TOKENS" ] && [ "$CACHE_TOKENS" -gt 0 ] 2>/dev/null; then
                  CACHE_TOKENS_FORMATTED=$(format_number "$CACHE_TOKENS")
                  echo "• 💾 Cache: ${CACHE_TOKENS_FORMATTED} tokens created" >> outputs/slack_response.txt
                fi
                echo "• 🏷️ Session: \`$SESSION_ID\`" >> outputs/slack_response.txt
                echo "• 🤖 Model: ${{ github.event.inputs.model || 'claude-sonnet-4-20250514' }}" >> outputs/slack_response.txt
                
                # Add status indicator if there was an error
                IS_ERROR=$(echo "$METADATA" | jq -r '.is_error // false')
                SUBTYPE=$(echo "$METADATA" | jq -r '.subtype // "success"')
                if [ "$IS_ERROR" = "true" ] || [ "$SUBTYPE" = "error_during_execution" ]; then
                  echo "• ⚠️ Status: Completed with warnings" >> outputs/slack_response.txt
                fi
                
                echo "Metadata appended to response file"
              else
                echo "Warning: Response file not found, metadata not appended"
              fi
            else
              echo "Warning: Could not parse metadata from execution file"
            fi
          else
            echo "Warning: Execution file not found at any location"
          fi
      
      - name: Handle Claude API Error
        if: steps.claude-process.outcome == 'failure'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          echo "Claude process outcome: ${{ steps.claude-process.outcome }}"
          echo "Claude API call failed. Analyzing error type..."
          
          # Create outputs directory if it doesn't exist
          mkdir -p outputs
          
          # Check for specific error types
          ERROR_TYPE="unknown"
          EXECUTION_FILE="/home/runner/work/_temp/claude-execution-output.json"
          
          if [ -f "$EXECUTION_FILE" ]; then
            # Check for tool_use/tool_result pairing error
            if grep -q "tool_use ids were found without tool_result blocks" "$EXECUTION_FILE"; then
              ERROR_TYPE="tool_pairing"
              echo "Detected tool_use/tool_result pairing error"
            elif grep -q "overloaded" "$EXECUTION_FILE" || grep -q "529" "$EXECUTION_FILE"; then
              ERROR_TYPE="overload"
              echo "Detected API overload error"
            elif grep -q "rate.limit" "$EXECUTION_FILE"; then
              ERROR_TYPE="rate_limit"
              echo "Detected rate limit error"
            fi
          fi
          
          # Create appropriate error message based on type
          if [ "$ERROR_TYPE" = "tool_pairing" ]; then
            cat > outputs/slack_response.txt << 'EOF'
          :warning: Claude encountered a tool usage error.
          
          **Error:** Tool call sequencing issue detected (duplicate or unpaired tool calls)
          
          This is a known issue that can occur when processing complex requests. The system attempted to make duplicate tool calls which violates API requirements.
          
          **Your request:** ${{ github.event.inputs.question }}
          **Session ID:** `${{ env.SESSION_ID }}`
          
          **To continue:**
          • `@claude continue` - I'll try again with better tool management
          • Or rephrase your request to be more specific
          
          The session has been saved, and I'll be more careful with tool usage next time!
          EOF
          else
            # Generic error message for other types
            cat > outputs/slack_response.txt << 'EOF'
          :hourglass_flowing_sand: Claude encountered an error processing your request.
          
          This could be due to high demand or a temporary API issue.
          
          **Your request:** ${{ github.event.inputs.question }}
          **Session ID:** `${{ env.SESSION_ID }}`
          
          Please try again in a few moments by mentioning me with:
          • `@claude continue` (to resume this exact request)
          • Or repeat your original request
          
          The session has been saved, so I can pick up where we left off!
          EOF
          fi
          
          echo "Created error response for type: $ERROR_TYPE"
          echo "Response file content:"
          cat outputs/slack_response.txt
      
      - name: Log turn allocation
        if: always()
        run: |
          echo "=== Turn Allocation ==="
          echo "Max Turns: ${{ github.event.inputs.max_turns || '15' }}"
          echo "======================="
      
      - name: Check for session continuation
        if: always()
        id: check-session
        run: |
          # Check if this task needs continuation
          if [ -f "outputs/checkpoints/progress.json" ] && [ -f "outputs/session_id.txt" ]; then
            SESSION_ID=$(cat outputs/session_id.txt)
            echo "session_needs_continuation=true" >> $GITHUB_OUTPUT
            echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
            
            # Extract pending steps for the response
            PENDING_STEPS=$(jq -r '.pending_steps[]' outputs/checkpoints/progress.json 2>/dev/null | head -5)
            if [ -n "$PENDING_STEPS" ]; then
              echo "pending_steps<<EOF" >> $GITHUB_OUTPUT
              echo "$PENDING_STEPS" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
          else
            echo "session_needs_continuation=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Update Slack Message
        if: always()
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          # Check if response file exists
          if [ -f "outputs/slack_response.txt" ]; then
            echo "Found response file, updating Slack message..."
            RESPONSE=$(cat outputs/slack_response.txt)
            
            # Escape the response for JSON
            ESCAPED_RESPONSE=$(echo "$RESPONSE" | jq -Rs .)
            
            # Update the placeholder message
            UPDATE_RESULT=$(curl -s -X POST https://slack.com/api/chat.update \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                \"ts\": \"${{ github.event.inputs.slack_ts }}\",
                \"text\": $ESCAPED_RESPONSE
              }")
            
            # Check if update was successful
            if echo "$UPDATE_RESULT" | jq -e '.ok == true' > /dev/null 2>&1; then
              echo "Successfully updated Slack message"
            else
              echo "Failed to update message, falling back to reply..."
              ERROR=$(echo "$UPDATE_RESULT" | jq -r '.error // "unknown error"')
              echo "Error: $ERROR"
              
              # Fallback: post as a reply
              REPLY_RESULT=$(curl -s -X POST https://slack.com/api/chat.postMessage \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                  \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                  \"thread_ts\": \"${{ github.event.inputs.slack_thread_ts || github.event.inputs.slack_ts }}\",
                  \"text\": $ESCAPED_RESPONSE
                }")
              
              if echo "$REPLY_RESULT" | jq -e '.ok == true' > /dev/null 2>&1; then
                echo "Successfully posted reply as fallback"
              else
                REPLY_ERROR=$(echo "$REPLY_RESULT" | jq -r '.error // "unknown error"')
                echo "Failed to post reply: $REPLY_ERROR"
              fi
            fi
            
            # Add continuation hint if session needs to continue
            if [ "${{ steps.check-session.outputs.session_needs_continuation }}" = "true" ]; then
              SESSION_ID="${{ steps.check-session.outputs.session_id }}"
              PENDING_STEPS="${{ steps.check-session.outputs.pending_steps }}"
              
              if [ -n "$PENDING_STEPS" ]; then
                CONTINUATION_MSG=":information_source: Task partially completed. To continue with remaining steps, mention me with: \`@claude continue\` or \`@claude continue session $SESSION_ID\`\n\nPending steps:\n$PENDING_STEPS"
                
                curl -X POST https://slack.com/api/chat.postMessage \
                  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "{
                    \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                    \"thread_ts\": \"${{ github.event.inputs.slack_thread_ts || github.event.inputs.slack_ts }}\",
                    \"text\": \"$CONTINUATION_MSG\"
                  }"
              fi
            fi
          else
            echo "No response file found, posting error message..."
            
            # Post an error message if no response was generated
            ERROR_MESSAGE=":warning: I encountered an error processing your request. Please check the workflow logs for details."
            curl -X POST https://slack.com/api/chat.update \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                \"ts\": \"${{ github.event.inputs.slack_ts }}\",
                \"text\": \"$ERROR_MESSAGE\"
              }"
          fi
      
      - name: Stop Progress Monitor
        if: always()
        run: |
          # Remove the running indicator
          rm -f .claude_running
          
          # Kill the progress monitor if still running
          if [ -f ".monitor_pid" ]; then
            MONITOR_PID=$(cat .monitor_pid)
            # Kill the process group to ensure all child processes are terminated
            kill -TERM -$MONITOR_PID 2>/dev/null || true
            sleep 1
            kill -KILL -$MONITOR_PID 2>/dev/null || true
            rm -f .monitor_pid
          fi
      
      - name: Upload checkpoint artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checkpoint-${{ env.SESSION_ID }}
          path: outputs/checkpoints/
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Create continuation workflow (if needed)
        if: steps.check-session.outputs.session_needs_continuation == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const sessionId = '${{ steps.check-session.outputs.session_id }}';
            console.log(`Task needs continuation. Session ID: ${sessionId}`);
            console.log('User can continue by saying "continue" in the Slack thread.');
            
            // Log the continuation info for debugging
            const checkpointPath = 'outputs/checkpoints/progress.json';
            const fs = require('fs');
            if (fs.existsSync(checkpointPath)) {
              const checkpoint = JSON.parse(fs.readFileSync(checkpointPath, 'utf8'));
              console.log('Checkpoint summary:', {
                phase: checkpoint.phase,
                progress: checkpoint.progress_percentage,
                pendingSteps: checkpoint.pending?.steps?.length || 0
              });
            }