name: Claude Code Processor (Best Experience)

on:
  workflow_dispatch:
    inputs:
      question:
        description: "User question from Slack"
        required: true
        type: string
      slack_channel:
        description: "Slack channel ID"
        required: true
        type: string
      slack_ts:
        description: "Slack message timestamp"
        required: true
        type: string
      slack_thread_ts:
        description: "Slack thread timestamp"
        required: false
        type: string
      system_prompt:
        description: "Additional context (e.g., thread history)"
        required: false
        type: string
      model:
        description: "Claude model to use"
        required: false
        type: string
        default: "claude-sonnet-4-20250514"
      repository_context:
        description: "JSON string with repository context information"
        required: false
        type: string
      max_turns:
        description: "Maximum conversation turns (dynamically calculated)"
        required: false
        type: string
        default: "15"
      timeout_minutes:
        description: "Workflow timeout in minutes (dynamically calculated)"
        required: false
        type: string
        default: "10"
      session_id:
        description: "Session ID to resume a previous conversation"
        required: false
        type: string

jobs:
  process-request:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_minutes || '10') }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup environment
        run: |
          mkdir -p outputs
          mkdir -p outputs/checkpoints
          mkdir -p ~/.local/bin
          
          # Create a file to indicate Claude is running
          touch .claude_running
          
          # Create session info file if resuming
          if [ -n "${{ github.event.inputs.session_id }}" ]; then
            echo "Resuming session: ${{ github.event.inputs.session_id }}"
            echo "${{ github.event.inputs.session_id }}" > outputs/session_id.txt
          fi
      
      - name: Install GitHub MCP Server
        run: |
          echo "Downloading github-mcp-server binary..."
          curl -L https://github.com/github/github-mcp-server/releases/download/v0.5.0/github-mcp-server_Linux_x86_64.tar.gz | tar xz -C ~/.local/bin
          chmod +x ~/.local/bin/github-mcp-server
          echo "$HOME/.local/bin" >> $GITHUB_PATH
      
      - name: Download previous checkpoint (if continuing)
        if: github.event.inputs.session_id != '' && github.event.inputs.session_id != 'null' && github.event.inputs.session_id != 'new-session'
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: checkpoint-${{ github.event.inputs.session_id }}
          path: outputs/checkpoints/
      
      - name: Start Progress Monitor
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: ${{ github.event.inputs.slack_channel }}
          SLACK_TS: ${{ github.event.inputs.slack_ts }}
        run: |
          # Background process to update Slack with progress
          # Use setsid to create a new process group for easier cleanup
          # Export variables for the subshell
          export SLACK_BOT_TOKEN SLACK_CHANNEL SLACK_TS
          
          setsid bash -c '
            while [ -f ".claude_running" ]; do
              if [ -f "outputs/checkpoints/progress.json" ]; then
                PROGRESS=$(jq -r ".progress_percentage // 0" outputs/checkpoints/progress.json 2>/dev/null || echo 0)
                PHASE=$(jq -r ".phase // \"initializing\"" outputs/checkpoints/progress.json 2>/dev/null || echo "initializing")
                
                # Create progress bar
                FILLED=$((PROGRESS / 5))
                EMPTY=$((20 - FILLED))
                BAR=""
                for i in $(seq 1 $FILLED); do BAR="${BAR}█"; done
                for i in $(seq 1 $EMPTY); do BAR="${BAR}░"; done
                
                # Update Slack message with progress
                curl -s -X POST https://slack.com/api/chat.update \
                  -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "{
                    \"channel\": \"${SLACK_CHANNEL}\",
                    \"ts\": \"${SLACK_TS}\",
                    \"text\": \"🤔 Working on your request... [${PROGRESS}%] - ${PHASE}\\n${BAR}\"
                  }" > /dev/null 2>&1
              fi
              sleep 30
            done
          ' > /tmp/progress_monitor.log 2>&1 &
          MONITOR_PID=$!
          echo "Progress monitor started with PID $MONITOR_PID"
          echo $MONITOR_PID > .monitor_pid
      
      - name: Configure Claude settings
        id: claude-config
        run: |
          # Model-specific settings
          if [[ "${{ github.event.inputs.model }}" == "claude-3-5-sonnet-20241022" ]]; then
            THINKING="false"
          else
            THINKING="true"
          fi
          
          # Output environment variables
          cat > claude_env.txt << EOF
          ANTHROPIC_PROMPT_CACHING=1
          CLAUDE_CODE_AUTORUN_TOOLS=true
          CLAUDE_CODE_THINKING=$THINKING
          CLAUDE_CODE_DANGEROUSLY_SKIP_PERMISSIONS=true
          EOF
          
          # Set output for GitHub Actions
          echo "claude_env<<EOF" >> $GITHUB_OUTPUT
          cat claude_env.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Process with Claude
        id: claude-process
        uses: anthropics/claude-code-base-action@beta
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          prompt: |
            You are Claude, a helpful Slack bot assistant.
            
            **User Question:** ${{ github.event.inputs.question }}
            **Channel:** ${{ github.event.inputs.slack_channel }}
            **Thread:** ${{ github.event.inputs.slack_thread_ts || github.event.inputs.slack_ts }}
            **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
            
            ## Instructions
            
            ### 0. Session Management
            - Session ID: ${{ github.event.inputs.session_id || 'new-session' }}
            - If this is a resumed session, check for checkpoint files in `outputs/checkpoints/`
            - Continue from the last checkpoint if available
            
            ### 1. Smart Checkpointing Rules
            Save checkpoint at these critical times:
            - After completing major phases (analysis, implementation, testing)
            - Before risky operations (file updates, PR creation)
            - When reaching 70% of allocated turns or time
            - After successful multi-file operations
            
            Checkpoint format (save to `outputs/checkpoints/progress.json`):
            ```json
            {
              "version": "1.0",
              "workflow_run_id": "${{ github.run_id }}",
              "workflow_run_number": "${{ github.run_number }}",
              "timestamp": "2025-01-01T00:00:00Z",
              "session_id": "${{ github.event.inputs.session_id || github.run_id }}",
              "phase": "analysis|implementation|testing|finalization",
              "progress_percentage": 25,
              "completed": {
                "files_created": ["file1.ts", "file2.ts"],
                "files_modified": ["file3.ts"],
                "analysis_complete": true,
                "pr_branch": "feature/xyz-12345"
              },
              "pending": {
                "steps": ["Create PR", "Add tests"],
                "estimated_turns": 10
              },
              "context": {
                "original_request": "${{ github.event.inputs.question }}",
                "key_findings": "...",
                "decisions_made": "..."
              }
            }
            ```
            
            ### 2. Process the Request
            - If resuming session, load checkpoint from outputs/checkpoints/progress.json
            - Analyze the user's question thoroughly
            - CRITICAL: If the question is short (e.g., "do it", "solve this", "continue"), check the thread context to understand what task to complete
            - Look for unfinished tasks or requests in the thread history and complete them
            - Use any necessary MCP tools to gather information
            - For GitHub repositories, check the repository context for access level
            - Repository context is provided in: ${{ github.event.inputs.repository_context }}
            - When creating branches, use unique names with timestamps: feature/[description]-[timestamp]
            - If branch creation fails due to "already exists", use a different name or timestamp
            - Save checkpoint BEFORE attempting complex GitHub operations
            
            ### CRITICAL: GitHub File Update Guidelines
            To prevent 10-minute timeouts when updating GitHub files:
            
            1. **Decision Rule**: 
               - NEW file (doesn't exist yet) → `mcp__github__create_or_update_file` ✅
               - EXISTING file (already in repo) → `mcp__github__push_files` ✅
               - Multiple files → Always `mcp__github__push_files` ✅
               - When unsure → Use `mcp__github__push_files` (works for both) ✅
            
            2. **Why This Matters**:
               - GitHub API REQUIRES current file SHA for updates
               - `create_or_update_file` can't get SHA = hangs for 10 minutes
               - `push_files` handles SHA automatically using Trees API
            
            3. **Common Tasks**:
               - "Fix typo" → Use `push_files` (file exists)
               - "Update config" → Use `push_files` (file exists)
               - "Add new feature" → Check first, if new use `create_or_update_file`
               - "Batch updates" → Always use `push_files`
            
            4. **Before Any File Operation**:
               - Think: "Does this file already exist in the repo?"
               - If YES or UNSURE → Use `push_files`
               - Only use `create_or_update_file` when 100% certain file is NEW
            
            ### 3. Save to Notion (Optional)
            - If Notion MCP is available, try to save Q&A to Notion
            - Search for "Claude Code" page using `mcp__notionApi__API-post-search`
            - If found, create a sub-page with the conversation
            
            ### 4. Resource Management
            Monitor your resource usage carefully:
            - Total turns available: ${{ github.event.inputs.max_turns || '15' }}
            - At 70% of turns: Start consolidating work and create comprehensive checkpoint
            - At 80%: Focus only on critical items, prepare for continuation
            - At 90%: Save all work immediately with detailed next steps
            - At 95%: Emergency save with exact continuation instructions
                ```
            - If you're running low on turns (less than 5 remaining), immediately save a checkpoint
            - This allows the task to be resumed if it times out or runs out of turns
            
            ### 4. CRITICAL: Check Thread Context First
            - If the message is short like "solve this", "do it", "continue", check the system prompt for thread context
            - The thread history shows what task was previously discussed
            - Complete the task mentioned in the thread without asking for clarification
            - Example: If thread mentions "create a PR", then "solve this" means create that PR
            
            ### 5. Save Response to File (REQUIRED)
            - IMPORTANT: You MUST save a response before running out of turns
            - Monitor your progress - if approaching turn limit, wrap up and save
            - Save your response to: `outputs/slack_response.txt`
            - Use the Write tool to save the file
            - Format your response appropriately for Slack (use markdown where helpful)
            - Save the clean response text that should be shown to the user
            - Metadata will be automatically appended to your response by the workflow
            - If you couldn't complete everything:
              - Save a final checkpoint with exact next steps
              - Include in response: "✅ Made significant progress! I've completed [X]. To finish [Y], just say 'continue'."
              - List what was accomplished and what remains
            
            ### Important Notes
            - The Slack MCP server cannot update messages, only post new ones
            - By saving to the file, the workflow can update the placeholder message
            - This provides a cleaner experience than posting a new reply
            - Make sure to save the response BEFORE attempting complex operations
            - If running low on turns, prioritize saving a partial response over completing everything
            - If task wasn't completed:
              - The system will automatically suggest continuation
              - User can simply say "continue" to resume
              - Session ID is managed automatically based on thread
          
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          anthropic_model: ${{ github.event.inputs.model }}
          append_system_prompt: ${{ github.event.inputs.system_prompt }}
          allowed_tools: |
            Write,
            Read,
            Bash,
            WebSearch,
            mcp__slack__slack_get_thread_replies,
            mcp__slack__slack_get_users,
            mcp__slack__slack_get_user_profile,
            mcp__slack__slack_get_channel_history,
            mcp__notionApi__API-post-search,
            mcp__notionApi__API-post-page,
            mcp__github__get_me,
            mcp__github__get_issue,
            mcp__github__get_issue_comments,
            mcp__github__list_issues,
            mcp__github__search_issues,
            mcp__github__create_issue,
            mcp__github__add_issue_comment,
            mcp__github__update_issue,
            mcp__github__get_pull_request,
            mcp__github__list_pull_requests,
            mcp__github__get_pull_request_files,
            mcp__github__get_pull_request_comments,
            mcp__github__get_pull_request_diff,
            mcp__github__get_pull_request_reviews,
            mcp__github__get_pull_request_status,
            mcp__github__create_pull_request,
            mcp__github__merge_pull_request,
            mcp__github__update_pull_request,
            mcp__github__update_pull_request_branch,
            mcp__github__create_pending_pull_request_review,
            mcp__github__add_pull_request_review_comment_to_pending_review,
            mcp__github__submit_pending_pull_request_review,
            mcp__github__delete_pending_pull_request_review,
            mcp__github__create_and_submit_pull_request_review,
            mcp__github__request_copilot_review,
            mcp__github__assign_copilot_to_issue,
            mcp__github__search_repositories,
            mcp__github__create_repository,
            mcp__github__fork_repository,
            mcp__github__get_file_contents,
            mcp__github__create_or_update_file,
            mcp__github__delete_file,
            mcp__github__push_files,
            mcp__github__create_branch,
            mcp__github__list_branches,
            mcp__github__list_commits,
            mcp__github__get_commit,
            mcp__github__search_code,
            mcp__github__list_tags,
            mcp__github__get_tag,
            mcp__github__search_users,
            mcp__github__list_notifications,
            mcp__github__get_notification_details,
            mcp__github__mark_all_notifications_read,
            mcp__github__dismiss_notification,
            mcp__github__manage_notification_subscription,
            mcp__github__manage_repository_notification_subscription,
            mcp__github__list_code_scanning_alerts,
            mcp__github__get_code_scanning_alert,
            mcp__github__list_secret_scanning_alerts,
            mcp__github__get_secret_scanning_alert
          mcp_config: |
            {
              "mcpServers": {
                "slack": {
                  "command": "npx",
                  "args": ["-y", "@modelcontextprotocol/server-slack"],
                  "env": { 
                    "SLACK_BOT_TOKEN": "${{ secrets.SLACK_BOT_TOKEN }}",
                    "SLACK_TEAM_ID": "${{ secrets.SLACK_TEAM_ID }}" 
                  }
                },
                "notionApi": {
                  "command": "npx",
                  "args": ["-y", "@notionhq/notion-mcp-server"],
                  "env": { 
                    "OPENAPI_MCP_HEADERS": "{\"Authorization\":\"Bearer ${{ secrets.NOTION_KEY }}\",\"Notion-Version\":\"2022-06-28\"}"
                  }
                },
                "github": {
                  "command": "github-mcp-server",
                  "args": ["stdio", "--toolsets", "all"],
                  "env": { 
                    "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GH_TOKEN }}" 
                  }
                }
              }
            }
          max_turns: ${{ github.event.inputs.max_turns || '15' }}
          claude_env: ${{ steps.claude-config.outputs.claude_env }}
      
      - name: Extract and Append Metadata
        if: steps.claude-process.outcome == 'success'
        continue-on-error: true
        run: |
          echo "Extracting metadata from Claude execution..."
          
          # Check if execution file exists
          EXECUTION_FILE="${{ steps.claude-process.outputs.execution_file }}"
          if [ -z "$EXECUTION_FILE" ] || [ ! -f "$EXECUTION_FILE" ]; then
            echo "No execution file found, checking default location..."
            # Try default location from logs
            EXECUTION_FILE="/home/runner/work/_temp/claude-execution-output.json"
          fi
          
          if [ -f "$EXECUTION_FILE" ]; then
            echo "Found execution file at: $EXECUTION_FILE"
            
            # Extract metadata using jq (handle both regular and error_during_execution results)
            METADATA=$(jq -r 'select(.type == "result") | {
              cost: .total_cost_usd,
              duration_ms: .duration_ms,
              duration_api_ms: .duration_api_ms,
              num_turns: .num_turns,
              session_id: .session_id,
              input_tokens: ((.usage.input_tokens // 0) + (.usage.cache_read_input_tokens // 0)),
              output_tokens: (.usage.output_tokens // 0),
              cache_creation_tokens: (.usage.cache_creation_input_tokens // 0),
              is_error: (.is_error // false),
              subtype: (.subtype // "success")
            }' "$EXECUTION_FILE" | tail -1)
            
            if [ -n "$METADATA" ] && [ "$METADATA" != "null" ]; then
              # Parse individual fields
              COST=$(echo "$METADATA" | jq -r '.cost // 0' | xargs printf "%.2f")
              DURATION_MS=$(echo "$METADATA" | jq -r '.duration_ms // 0')
              API_DURATION_MS=$(echo "$METADATA" | jq -r '.duration_api_ms // 0')
              NUM_TURNS=$(echo "$METADATA" | jq -r '.num_turns // 0')
              SESSION_ID=$(echo "$METADATA" | jq -r '.session_id // "unknown"')
              INPUT_TOKENS=$(echo "$METADATA" | jq -r '.input_tokens // 0')
              OUTPUT_TOKENS=$(echo "$METADATA" | jq -r '.output_tokens // 0')
              CACHE_TOKENS=$(echo "$METADATA" | jq -r '.cache_creation_tokens // 0')
              
              # Convert durations to human-readable format
              DURATION_SEC=$((DURATION_MS / 1000))
              DURATION_MIN=$((DURATION_SEC / 60))
              DURATION_REMAINING_SEC=$((DURATION_SEC % 60))
              
              API_DURATION_SEC=$((API_DURATION_MS / 1000))
              API_DURATION_MIN=$((API_DURATION_SEC / 60))
              API_DURATION_REMAINING_SEC=$((API_DURATION_SEC % 60))
              
              # Format token numbers with commas
              format_number() {
                echo "$1" | sed ':a;s/\B[0-9]\{3\}\>/,&/;ta'
              }
              
              INPUT_TOKENS_FORMATTED=$(format_number "$INPUT_TOKENS")
              OUTPUT_TOKENS_FORMATTED=$(format_number "$OUTPUT_TOKENS")
              TOTAL_TOKENS=$((${INPUT_TOKENS:-0} + ${OUTPUT_TOKENS:-0}))
              TOTAL_TOKENS_FORMATTED=$(format_number "$TOTAL_TOKENS")
              
              # Append metadata to response file
              if [ -f "outputs/slack_response.txt" ]; then
                echo "" >> outputs/slack_response.txt
                echo "---" >> outputs/slack_response.txt
                echo "📊 **Execution Details**" >> outputs/slack_response.txt
                echo "• 💰 Cost: \$$COST" >> outputs/slack_response.txt
                echo "• ⏱️ Duration: ${DURATION_MIN}m ${DURATION_REMAINING_SEC}s (API: ${API_DURATION_MIN}m ${API_DURATION_REMAINING_SEC}s)" >> outputs/slack_response.txt
                echo "• 🔄 Turns: $NUM_TURNS/${{ github.event.inputs.max_turns || '15' }}" >> outputs/slack_response.txt
                echo "• 🎯 Tokens: ${INPUT_TOKENS_FORMATTED} in / ${OUTPUT_TOKENS_FORMATTED} out (${TOTAL_TOKENS_FORMATTED} total)" >> outputs/slack_response.txt
                if [ -n "$CACHE_TOKENS" ] && [ "$CACHE_TOKENS" -gt 0 ] 2>/dev/null; then
                  CACHE_TOKENS_FORMATTED=$(format_number "$CACHE_TOKENS")
                  echo "• 💾 Cache: ${CACHE_TOKENS_FORMATTED} tokens created" >> outputs/slack_response.txt
                fi
                echo "• 🏷️ Session: \`$SESSION_ID\`" >> outputs/slack_response.txt
                echo "• 🤖 Model: ${{ github.event.inputs.model || 'claude-sonnet-4-20250514' }}" >> outputs/slack_response.txt
                
                # Add status indicator if there was an error
                IS_ERROR=$(echo "$METADATA" | jq -r '.is_error // false')
                SUBTYPE=$(echo "$METADATA" | jq -r '.subtype // "success"')
                if [ "$IS_ERROR" = "true" ] || [ "$SUBTYPE" = "error_during_execution" ]; then
                  echo "• ⚠️ Status: Completed with warnings" >> outputs/slack_response.txt
                fi
                
                echo "Metadata appended to response file"
              else
                echo "Warning: Response file not found, metadata not appended"
              fi
            else
              echo "Warning: Could not parse metadata from execution file"
            fi
          else
            echo "Warning: Execution file not found at any location"
          fi
      
      - name: Handle Claude API Error
        if: steps.claude-process.outcome == 'failure'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          echo "Claude process outcome: ${{ steps.claude-process.outcome }}"
          echo "Claude API call failed. Since we had an API failure, providing helpful retry message..."
          
          # Since the Claude process failed and no response was generated,
          # we'll assume it could be an overload or other API issue
          # Always provide a helpful message with retry instructions
          
          # Create outputs directory if it doesn't exist
          mkdir -p outputs
          
          # Create a response file with retry instructions
          cat > outputs/slack_response.txt << 'EOF'
          :hourglass_flowing_sand: Claude encountered an error processing your request.
          
          This could be due to high demand or a temporary API issue.
          
          **Your request:** ${{ github.event.inputs.question }}
          **Session ID:** `${{ github.event.inputs.session_id || github.run_id }}`
          
          Please try again in a few moments by mentioning me with:
          • `@claude continue` (to resume this exact request)
          • Or repeat your original request
          
          The session has been saved, so I can pick up where we left off!
          EOF
          
          echo "Created error response with retry instructions"
          echo "Response file content:"
          cat outputs/slack_response.txt
      
      - name: Log turn allocation
        if: always()
        run: |
          echo "=== Turn Allocation ==="
          echo "Max Turns: ${{ github.event.inputs.max_turns || '15' }}"
          echo "======================="
      
      - name: Check for session continuation
        if: always()
        id: check-session
        run: |
          # Check if this task needs continuation
          if [ -f "outputs/checkpoints/progress.json" ] && [ -f "outputs/session_id.txt" ]; then
            SESSION_ID=$(cat outputs/session_id.txt)
            echo "session_needs_continuation=true" >> $GITHUB_OUTPUT
            echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
            
            # Extract pending steps for the response
            PENDING_STEPS=$(jq -r '.pending_steps[]' outputs/checkpoints/progress.json 2>/dev/null | head -5)
            if [ -n "$PENDING_STEPS" ]; then
              echo "pending_steps<<EOF" >> $GITHUB_OUTPUT
              echo "$PENDING_STEPS" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
          else
            echo "session_needs_continuation=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Update Slack Message
        if: always()
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          # Check if response file exists
          if [ -f "outputs/slack_response.txt" ]; then
            echo "Found response file, updating Slack message..."
            RESPONSE=$(cat outputs/slack_response.txt)
            
            # Escape the response for JSON
            ESCAPED_RESPONSE=$(echo "$RESPONSE" | jq -Rs .)
            
            # Update the placeholder message
            UPDATE_RESULT=$(curl -s -X POST https://slack.com/api/chat.update \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                \"ts\": \"${{ github.event.inputs.slack_ts }}\",
                \"text\": $ESCAPED_RESPONSE
              }")
            
            # Check if update was successful
            if echo "$UPDATE_RESULT" | jq -e '.ok == true' > /dev/null 2>&1; then
              echo "Successfully updated Slack message"
            else
              echo "Failed to update message, falling back to reply..."
              ERROR=$(echo "$UPDATE_RESULT" | jq -r '.error // "unknown error"')
              echo "Error: $ERROR"
              
              # Fallback: post as a reply
              REPLY_RESULT=$(curl -s -X POST https://slack.com/api/chat.postMessage \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                  \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                  \"thread_ts\": \"${{ github.event.inputs.slack_thread_ts || github.event.inputs.slack_ts }}\",
                  \"text\": $ESCAPED_RESPONSE
                }")
              
              if echo "$REPLY_RESULT" | jq -e '.ok == true' > /dev/null 2>&1; then
                echo "Successfully posted reply as fallback"
              else
                REPLY_ERROR=$(echo "$REPLY_RESULT" | jq -r '.error // "unknown error"')
                echo "Failed to post reply: $REPLY_ERROR"
              fi
            fi
            
            # Add continuation hint if session needs to continue
            if [ "${{ steps.check-session.outputs.session_needs_continuation }}" = "true" ]; then
              SESSION_ID="${{ steps.check-session.outputs.session_id }}"
              PENDING_STEPS="${{ steps.check-session.outputs.pending_steps }}"
              
              if [ -n "$PENDING_STEPS" ]; then
                CONTINUATION_MSG=":information_source: Task partially completed. To continue with remaining steps, mention me with: \`continue session $SESSION_ID\`\n\nPending steps:\n$PENDING_STEPS"
                
                curl -X POST https://slack.com/api/chat.postMessage \
                  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "{
                    \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                    \"thread_ts\": \"${{ github.event.inputs.slack_thread_ts || github.event.inputs.slack_ts }}\",
                    \"text\": \"$CONTINUATION_MSG\"
                  }"
              fi
            fi
          else
            echo "No response file found, posting error message..."
            
            # Post an error message if no response was generated
            ERROR_MESSAGE=":warning: I encountered an error processing your request. Please check the workflow logs for details."
            curl -X POST https://slack.com/api/chat.update \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                \"channel\": \"${{ github.event.inputs.slack_channel }}\",
                \"ts\": \"${{ github.event.inputs.slack_ts }}\",
                \"text\": \"$ERROR_MESSAGE\"
              }"
          fi
      
      - name: Stop Progress Monitor
        if: always()
        run: |
          # Remove the running indicator
          rm -f .claude_running
          
          # Kill the progress monitor if still running
          if [ -f ".monitor_pid" ]; then
            MONITOR_PID=$(cat .monitor_pid)
            # Kill the process group to ensure all child processes are terminated
            kill -TERM -$MONITOR_PID 2>/dev/null || true
            sleep 1
            kill -KILL -$MONITOR_PID 2>/dev/null || true
            rm -f .monitor_pid
          fi
      
      - name: Upload checkpoint artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checkpoint-${{ github.event.inputs.session_id || github.run_id }}
          path: outputs/checkpoints/
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Create continuation workflow (if needed)
        if: steps.check-session.outputs.session_needs_continuation == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const sessionId = '${{ steps.check-session.outputs.session_id }}';
            console.log(`Task needs continuation. Session ID: ${sessionId}`);
            console.log('User can continue by saying "continue" in the Slack thread.');
            
            // Log the continuation info for debugging
            const checkpointPath = 'outputs/checkpoints/progress.json';
            const fs = require('fs');
            if (fs.existsSync(checkpointPath)) {
              const checkpoint = JSON.parse(fs.readFileSync(checkpointPath, 'utf8'));
              console.log('Checkpoint summary:', {
                phase: checkpoint.phase,
                progress: checkpoint.progress_percentage,
                pendingSteps: checkpoint.pending?.steps?.length || 0
              });
            }